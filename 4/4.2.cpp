#include <iostream>
#include <vector>
#include <chrono>
#include <omp.h>
#include <cstdlib>
#include <ctime>
#include <windows.h>
#include <iomanip>

const int N = 10000;

// Функция для генерации случайных чисел и заполнения массива
void заполнитьМассив(std::vector<int>& массив) {
    for (auto& элемент : массив) {
        элемент = rand() % 1000;
    }
}

// Последовательная версия сортировки методом нечётно-чётной транспозиции
void сортировкаПоследовательная(std::vector<int>& массив) {
    bool отсортирован = false;
    int размер = массив.size();

    while (!отсортирован) {
        отсортирован = true;

        // Нечётная фаза
        for (int i = 1; i < размер - 1; i += 2) {
            if (массив[i] > массив[i + 1]) {
                std::swap(массив[i], массив[i + 1]);
                отсортирован = false;
            }
        }

        // Чётная фаза
        for (int i = 0; i < размер - 1; i += 2) {
            if (массив[i] > массив[i + 1]) {
                std::swap(массив[i], массив[i + 1]);
                отсортирован = false;
            }
        }
    }
}

// Параллельная версия сортировки методом нечётно-чётной транспозиции
void сортировкаПараллельная(std::vector<int>& массив) {
    bool отсортирован = false;
    int размер = массив.size();

    while (!отсортирован) {
        отсортирован = true;

        // Нечётная фаза
#pragma omp parallel for shared(массив, отсортирован)
        for (int i = 1; i < размер - 1; i += 2) {
            if (массив[i] > массив[i + 1]) {
                std::swap(массив[i], массив[i + 1]);
#pragma omp critical
                отсортирован = false;
            }
        }

        // Чётная фаза
#pragma omp parallel for shared(массив, отсортирован)
        for (int i = 0; i < размер - 1; i += 2) {
            if (массив[i] > массив[i + 1]) {
                std::swap(массив[i], массив[i + 1]);
#pragma omp critical
                отсортирован = false;
            }
        }
    }
}

int main() {
    // Установка кодировки и локали для поддержки русского языка в консоли
    SetConsoleOutputCP(65001);
    setlocale(LC_ALL, "Russian");

    omp_set_num_threads(4);

    std::vector<int> массивПоследовательный(N);
    std::vector<int> массивПараллельный(N);

    srand(static_cast<unsigned int>(time(nullptr)));

    std::cout << "=======================================================\n";
    std::cout << "           Сравнение производительности сортировок\n";
    std::cout << "     Метод нечётно-чётной транспозиции (Odd-Even Sort)\n";
    std::cout << "=======================================================\n";
    std::cout << "Размер массива: " << N << " элементов\n\n";

    // Заполнение массивов случайными числами
    заполнитьМассив(массивПоследовательный);
    массивПараллельный = массивПоследовательный;

    // Последовательная сортировка
    auto начало = std::chrono::high_resolution_clock::now();
    сортировкаПоследовательная(массивПоследовательный);
    auto конец = std::chrono::high_resolution_clock::now();
    double времяПоследовательно = std::chrono::duration<double>(конец - начало).count();

    std::cout << "Результат последовательной сортировки:\n";
    std::cout << "Время выполнения: " << std::fixed << std::setprecision(6) << времяПоследовательно << " секунд\n\n";

    // Параллельная сортировка
    начало = std::chrono::high_resolution_clock::now();
    сортировкаПараллельная(массивПараллельный);
    конец = std::chrono::high_resolution_clock::now();
    double времяПараллельно = std::chrono::duration<double>(конец - начало).count();

    std::cout << "Результат параллельной сортировки:\n";
    std::cout << "Время выполнения: " << std::fixed << std::setprecision(6) << времяПараллельно << " секунд\n\n";

    std::cout << "=======================================================\n";
    std::cout << "Сравнительный анализ:\n";
    std::cout << "Ускорение за счёт параллельной обработки: "
        << std::fixed << std::setprecision(2)
        << (времяПоследовательно / времяПараллельно) << " раз(а)\n";
    std::cout << "=======================================================\n";

    return 0;
}
